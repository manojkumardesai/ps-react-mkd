{"version":3,"sources":["../../../../src/icons/general/IconEdit.js","../node_modules/lodash/isEqual.js","../../../../src/components/pill-selector-dropdown/Pill.js","../../../../src/components/pill-selector-dropdown/SuggestedPill.js","../../../../src/components/pill-selector-dropdown/SuggestedPillsRow.js","../../../../src/components/pill-selector-dropdown/PillSelector.js","../node_modules/react-textarea-autosize/dist/react-textarea-autosize.esm.browser.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../../../../../src/elements/content-sidebar/skills/status/Status.js","../../../../src/icons/general/IconCopy.js","../../../../src/icons/general/IconExpand.js","../../../../src/icons/general/IconCollapse.js","../../../src/utils/download.js","../../../../../../src/elements/content-sidebar/skills/transcript/timeSliceUtils.js","../../../../../../src/elements/content-sidebar/skills/transcript/ReadOnlyTranscriptRow.js","../../../../../../src/elements/content-sidebar/skills/transcript/EditingTranscriptRow.js","../../../../../../src/elements/content-sidebar/skills/transcript/TranscriptRow.js","../../../../../../src/elements/content-sidebar/skills/transcript/Transcript.js","../../../../../../src/elements/content-sidebar/skills/keywords/keywordUtils.js","../../../../../../src/elements/content-sidebar/skills/keywords/EditableKeywords.js","../../../../src/components/pill-cloud/PillCloud.js","../../../../src/icons/general/IconTrackNext.js","../../../../src/icons/general/IconTrackPrevious.js","../../../../../../src/elements/content-sidebar/skills/timeline/Timeslice.js","../../../../../../src/elements/content-sidebar/skills/timeline/Timeline.js","../../../../../../src/elements/content-sidebar/skills/keywords/ReadOnlyKeywords.js","../../../../../../src/elements/content-sidebar/skills/keywords/Keywords.js","../../../../src/icons/general/IconMinus.js","../../../../../../src/elements/content-sidebar/skills/faces/Face.js","../../../../../../src/elements/content-sidebar/skills/faces/Faces.js","../../../../../src/elements/content-sidebar/skills/SidebarSkillsCard.js","../../../../../src/elements/content-sidebar/skills/SidebarSkills.js","../../../../src/elements/content-sidebar/SkillsSidebar.js"],"names":["className","color","height","title","width","viewBox","d","fill","baseIsEqual","require","module","exports","value","other","isDisabled","isSelected","isValid","onRemove","text","styles","classNames","onClick","aria-hidden","email","id","name","onAdd","addSuggestedPill","event","type","position","onKeyDown","KEYS","onSuggestedPillAdd","noop","selectedPillsValues","suggestedPillsData","suggestedPillsFilter","filteredSuggestedPillData","item","key","stopDefaultEvent","PillSelector","isFocused","selectedIndex","selectedOptions","option","inputValue","numPills","index","Math","uniqueId","this","allowInvalidPills","disabled","error","inputProps","onInput","placeholder","suggestedPillsTitle","validator","rest","suggestedPillsEnabled","hasError","classes","ariaAttrs","errorMessageID","isShown","theme","onBlur","onFocus","handleKeyDown","ref","tabIndex","autoComplete","getNumSelected","input","getPillsByKey","role","React","isIE","document","documentElement","currentStyle","HIDDEN_TEXTAREA_STYLE","visibility","overflow","top","right","SIZING_STYLE","computedStyleCache","hiddenTextarea","createElement","forceHiddenStyles","node","Object","keys","forEach","style","setProperty","calculateNodeHeight","uiTextNode","uid","useCache","minRows","maxRows","parentNode","body","appendChild","nodeStyling","window","getComputedStyle","sizingStyle","reduce","obj","getPropertyValue","boxSizing","parseFloat","paddingSize","borderSize","nodeInfo","calculateNodeStyling","minHeight","Infinity","maxHeight","scrollHeight","singleRowHeight","valueRowCount","floor","max","min","rowCount","setAttribute","TextareaAutosize","_React$Component","props","_this","call","_onRef","_ref","inputRef","current","_onChange","_controlled","_resizeComponent","onChange","self","ReferenceError","_assertThisInitialized","callback","nodeHeight","_uid","useCacheForDOMMeasurements","state","setState","undefined","_resizeLock","_inheritsLoose","_proto","prototype","render","_this$props","onHeightChange","_objectWithoutPropertiesLoose","_extends","componentDidMount","_this2","_resizeListener","addEventListener","componentDidUpdate","prevProps","prevState","componentWillUnmount","removeEventListener","purgeCache","Component","defaultProps","card","status","code","message","localizedMessage","messages","copy","string","textarea","isValidStartTime","timeslice","isValidTimeSlice","timeslices","Array","time","interactionTarget","data-resin-target","onSave","onCancel","SKILLS_TARGETS","appears","isEditing","timeSlice","start","formatTime","isEditingIndex","newTranscriptText","isCollapsed","isLoading","isEditingRow","transcriptText","entries","onSkillChange","entry","replacement","replaced","currentTarget","setTimeout","wasEditing","getViewer","viewer","isEditable","hasEntries","hasManyEntries","editBtnClassName","contentClassName","expandCollapseMessage","getDOMRef","bdlGray50","keywords","displayText","keyword","onDelete","isInCompositionMode","pills","getPills","prevKeywords","onCompositionEnd","onCompositionStart","onPaste","options","onSelect","buttonProps","op","isEqual","end","duration","startLeft","minEnding","ending","left","timeSliceIndex","playSegment","incr","newIndex","validTime","pill","selected","pillCloudProps","transcript","adds","locations","regex","RegExp","removes","addedIndex","added","hasKeywords","editClassName","PureComponent","fillRule","face","isAnyFaceSelected","isCurrentFaceSelected","isFaceSelected","faceClassName","alt","src","COLOR_WHITE","faces","hasFaces","cards","file","errors","isSkillEditable","SKILLS_ERROR_UNKNOWN","cardId","isValidSkillsCard","skill_card_type","getCardInteractionTarget","skill_card_title","defaultKey","defaultMessage","getCardTitle","isOpen","args","MARK_NAME_JS_READY","mark","SkillsSidebar","getPreview","preview","transcriptCard","loadedViewer","clone","replaces","api","path","ops","canEdit","getProp","idx","deletes","removed","b","logger","endMarkName","prevRefreshIdentity","refreshIdentity","elementId","sidebarView","flow","withLogger","withErrorBoundary"],"mappings":"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","file":"static/js/6.a1cf50ca.chunk.js","sourcesContent":["// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconEdit = ({ className = '', color = '#999', height = 14, title, width = 14 }: Props) => (\n    <AccessibleSVG className={`icon-edit ${className}`} height={height} title={title} viewBox=\"0 0 14 14\" width={width}>\n        <path\n            className=\"fill-color\"\n            d=\"M3.21 7.89l6.47-6.48a2 2 0 0 1 2.88 2.78h-.05L6 10.72 3.21 7.89zM2.24 9l2.83 2.83L1.67 13c-.52.18-.79-.1-.62-.61z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconEdit;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","// @flow\nimport React from 'react';\nimport noop from 'lodash/noop';\nimport classNames from 'classnames';\n\ntype Props = {\n    isDisabled?: boolean,\n    isSelected?: boolean,\n    isValid?: boolean,\n    onRemove: Function,\n    text: string,\n};\n\nconst Pill = ({ isDisabled = false, isSelected = false, isValid = true, onRemove, text }: Props) => {\n    const styles = classNames('pill', {\n        'is-selected': isSelected && !isDisabled,\n        'is-invalid': !isValid,\n        'is-disabled': isDisabled,\n    });\n    const onClick = isDisabled ? noop : onRemove;\n\n    return (\n        <span className={styles}>\n            <span className=\"pill-text\">{text}</span>\n            <span aria-hidden=\"true\" className=\"close-btn\" onClick={onClick}>\n                ✕\n            </span>\n        </span>\n    );\n};\n\nexport default Pill;\n","// @flow\nimport React from 'react';\n\nimport PlainButton from '../plain-button';\nimport Tooltip from '../tooltip';\nimport { KEYS } from '../../constants';\n\nimport { type SuggestedPill as SuggestedPillType } from './flowTypes';\n\nimport './SuggestedPillsRow.scss';\n\ntype Props = {\n    email: string,\n    id: number,\n    name: string,\n    onAdd: SuggestedPillType => void,\n};\n\nconst SuggestedPill = ({ email, id, name, onAdd }: Props) => {\n    const addSuggestedPill = (event: SyntheticEvent<HTMLButtonElement>) => {\n        event.preventDefault();\n\n        onAdd({\n            email,\n            id,\n            name,\n            text: name,\n            type: 'user',\n            value: email,\n        });\n    };\n\n    const handleKeyPress = (event: SyntheticKeyboardEvent<HTMLButtonElement>) => {\n        if (event.key === KEYS.enter) {\n            addSuggestedPill(event);\n        }\n    };\n\n    return (\n        <Tooltip position=\"bottom-center\" text={email}>\n            <PlainButton\n                className=\"suggested-pill-invisible-button\"\n                onClick={addSuggestedPill}\n                onKeyDown={handleKeyPress}\n                type=\"button\"\n            >\n                <span className=\"pill-text suggested-pill\">{name}</span>\n            </PlainButton>\n        </Tooltip>\n    );\n};\n\nexport default SuggestedPill;\n","// @flow\nimport React from 'react';\nimport noop from 'lodash/noop';\n\nimport SuggestedPill from './SuggestedPill';\nimport type { SuggestedPill as SuggestedPillType, SuggestedPills, SuggestedPillsFilter } from './flowTypes';\n\nimport './SuggestedPillsRow.scss';\n\ntype Props = {\n    onSuggestedPillAdd?: SuggestedPillType => void,\n    selectedPillsValues?: Array<number>,\n    suggestedPillsData?: SuggestedPills,\n    suggestedPillsFilter?: SuggestedPillsFilter,\n    title?: string,\n};\n\nconst SuggestedPillsRow = ({\n    onSuggestedPillAdd = noop,\n    selectedPillsValues = [],\n    suggestedPillsData = [],\n    suggestedPillsFilter = 'id',\n    title,\n}: Props) => {\n    // Prevents pills from being rendered that are in the form by checking for value (id or custom value)\n    const filteredSuggestedPillData = suggestedPillsData.filter(\n        item => !selectedPillsValues.includes(item[suggestedPillsFilter]),\n    );\n\n    if (filteredSuggestedPillData.length === 0) {\n        return null;\n    }\n\n    return (\n        <div className=\"pill-selector-suggested\">\n            <span>{title}</span>\n            {filteredSuggestedPillData.map(item => (\n                <SuggestedPill\n                    key={item.id}\n                    email={item.email}\n                    id={item.id}\n                    name={item.name}\n                    onAdd={onSuggestedPillAdd}\n                />\n            ))}\n        </div>\n    );\n};\n\nexport default SuggestedPillsRow;\n","// @flow\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport uniqueId from 'lodash/uniqueId';\n\nimport Tooltip from '../tooltip';\nimport { KEYS } from '../../constants';\n\nimport Pill from './Pill';\nimport SuggestedPillsRow from './SuggestedPillsRow';\nimport type { Option, OptionValue, SelectedOptions, SuggestedPillsFilter } from './flowTypes';\n\nfunction stopDefaultEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\n\ntype Props = {\n    allowInvalidPills: boolean,\n    className?: string,\n    disabled?: boolean,\n    error?: React.Node,\n    inputProps: Object,\n    onInput: Function,\n    onRemove: Function,\n    onSuggestedPillAdd?: Function,\n    placeholder: string,\n    selectedOptions: SelectedOptions,\n    suggestedPillsData?: Array<Object>,\n    suggestedPillsFilter?: SuggestedPillsFilter,\n    suggestedPillsTitle?: string,\n    validator: (option: Option | OptionValue) => boolean,\n};\n\ntype State = {\n    isFocused: boolean,\n    selectedIndex: number,\n};\n\nclass PillSelector extends React.Component<Props, State> {\n    static defaultProps = {\n        allowInvalidPills: false,\n        disabled: false,\n        error: '',\n        inputProps: {},\n        placeholder: '',\n        selectedOptions: [],\n        validator: () => true,\n    };\n\n    state = {\n        isFocused: false,\n        selectedIndex: -1,\n    };\n\n    getNumSelected = (): number => {\n        const { selectedOptions } = this.props;\n\n        return typeof selectedOptions.size === 'number' ? selectedOptions.size : selectedOptions.length;\n    };\n\n    getPillsByKey = (key: string): Array<any> => {\n        const { selectedOptions } = this.props;\n\n        return selectedOptions.map(option => option[key]);\n    };\n\n    inputEl: HTMLInputElement;\n\n    handleClick = () => {\n        this.inputEl.focus();\n    };\n\n    handleFocus = () => {\n        this.setState({ isFocused: true });\n    };\n\n    handleBlur = () => {\n        this.setState({ isFocused: false });\n    };\n\n    hiddenEl: HTMLSpanElement;\n\n    handleKeyDown = (event: SyntheticKeyboardEvent<>) => {\n        const inputValue = this.inputEl.value;\n        const numPills = this.getNumSelected();\n        const { selectedIndex } = this.state;\n\n        switch (event.key) {\n            case KEYS.backspace: {\n                let index = -1;\n                if (selectedIndex >= 0) {\n                    // remove selected pill\n                    index = selectedIndex;\n                    this.resetSelectedIndex();\n                    this.inputEl.focus();\n                } else if (inputValue === '') {\n                    // remove last pill\n                    index = numPills - 1;\n                }\n                if (index >= 0) {\n                    const { onRemove, selectedOptions } = this.props;\n                    const selectedOption =\n                        // $FlowFixMe\n                        typeof selectedOptions.get === 'function' ? selectedOptions.get(index) : selectedOptions[index];\n                    onRemove(selectedOption, index);\n                    stopDefaultEvent(event);\n                }\n                break;\n            }\n            case KEYS.arrowLeft:\n                if (selectedIndex >= 0) {\n                    // select previous pill\n                    this.setState({\n                        selectedIndex: Math.max(selectedIndex - 1, 0),\n                    });\n                    stopDefaultEvent(event);\n                } else if (inputValue === '' && numPills > 0) {\n                    // select last pill\n                    this.hiddenEl.focus();\n                    this.setState({ selectedIndex: numPills - 1 });\n                    stopDefaultEvent(event);\n                }\n                break;\n            case KEYS.arrowRight: {\n                if (selectedIndex >= 0) {\n                    const index = selectedIndex + 1;\n                    if (index >= numPills) {\n                        // deselect last pill\n                        this.resetSelectedIndex();\n                        this.inputEl.focus();\n                    } else {\n                        // select next pill\n                        this.setState({ selectedIndex: index });\n                    }\n                    stopDefaultEvent(event);\n                }\n                break;\n            }\n            // no default\n        }\n    };\n\n    errorMessageID = uniqueId('errorMessage');\n\n    hiddenRef = (hiddenEl: ?HTMLSpanElement) => {\n        if (hiddenEl) {\n            this.hiddenEl = hiddenEl;\n        }\n    };\n\n    resetSelectedIndex = () => {\n        if (this.state.selectedIndex !== -1) {\n            this.setState({ selectedIndex: -1 });\n        }\n    };\n\n    render() {\n        const { isFocused, selectedIndex } = this.state;\n        const {\n            allowInvalidPills,\n            className,\n            disabled,\n            error,\n            inputProps,\n            onInput,\n            onRemove,\n            onSuggestedPillAdd,\n            placeholder,\n            selectedOptions,\n            suggestedPillsData,\n            suggestedPillsFilter,\n            suggestedPillsTitle,\n            validator,\n            ...rest\n        } = this.props;\n        const suggestedPillsEnabled = suggestedPillsData && suggestedPillsData.length > 0;\n        const hasError = !!error;\n        const classes = classNames('pill-selector-input-wrapper', {\n            'is-disabled': disabled,\n            'is-focused': isFocused,\n            'show-error': hasError,\n            'pill-selector-suggestions-enabled': suggestedPillsEnabled,\n        });\n        const ariaAttrs = {\n            'aria-invalid': hasError,\n            'aria-errormessage': this.errorMessageID,\n        };\n\n        return (\n            <Tooltip isShown={hasError} text={error || ''} position=\"middle-right\" theme=\"error\">\n                {/* eslint-disable-next-line jsx-a11y/no-static-element-interactions */}\n                <span\n                    className={classes}\n                    onBlur={this.handleBlur}\n                    onClick={this.handleClick}\n                    onFocus={this.handleFocus}\n                    onKeyDown={this.handleKeyDown}\n                >\n                    {selectedOptions.map((option: Option, index: number) => (\n                        <Pill\n                            isValid={allowInvalidPills ? validator(option) : true}\n                            isDisabled={disabled}\n                            isSelected={index === selectedIndex}\n                            key={option.value}\n                            onRemove={onRemove.bind(this, option, index)}\n                            // $FlowFixMe option.text is for backwards compatibility\n                            text={option.displayText || option.text}\n                        />\n                    ))}\n                    {/* hidden element for focus/key events during pill selection */}\n                    <span\n                        aria-hidden=\"true\"\n                        className=\"accessibility-hidden\"\n                        onBlur={this.resetSelectedIndex}\n                        ref={this.hiddenRef}\n                        tabIndex={-1}\n                        data-testid=\"pill-selection-helper\"\n                    />\n                    <textarea\n                        {...ariaAttrs}\n                        {...rest}\n                        {...inputProps}\n                        autoComplete=\"off\"\n                        className={classNames('pill-selector-input', className)}\n                        disabled={disabled}\n                        onInput={onInput}\n                        placeholder={this.getNumSelected() === 0 ? placeholder : ''}\n                        ref={input => {\n                            this.inputEl = input;\n                        }}\n                    />\n                    <SuggestedPillsRow\n                        onSuggestedPillAdd={onSuggestedPillAdd}\n                        selectedPillsValues={this.getPillsByKey('value')}\n                        suggestedPillsFilter={suggestedPillsFilter}\n                        suggestedPillsData={suggestedPillsData}\n                        title={suggestedPillsTitle}\n                    />\n                    <span id={this.errorMessageID} className=\"accessibility-hidden\" role=\"alert\">\n                        {error}\n                    </span>\n                </span>\n            </Tooltip>\n        );\n    }\n}\n\nexport default PillSelector;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport { createElement, Component } from 'react';\nimport { oneOfType, func, shape, any, number, object, bool, string } from 'prop-types';\n\nvar isIE =  !!document.documentElement.currentStyle ;\nvar HIDDEN_TEXTAREA_STYLE = {\n  'min-height': '0',\n  'max-height': 'none',\n  height: '0',\n  visibility: 'hidden',\n  overflow: 'hidden',\n  position: 'absolute',\n  'z-index': '-1000',\n  top: '0',\n  right: '0'\n};\nvar SIZING_STYLE = ['letter-spacing', 'line-height', 'font-family', 'font-weight', 'font-size', 'font-style', 'tab-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left', 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width', 'box-sizing'];\nvar computedStyleCache = {};\nvar hiddenTextarea =  document.createElement('textarea');\n\nvar forceHiddenStyles = function forceHiddenStyles(node) {\n  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {\n    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');\n  });\n};\n\n{\n  hiddenTextarea.setAttribute('tab-index', '-1');\n  hiddenTextarea.setAttribute('aria-hidden', 'true');\n  forceHiddenStyles(hiddenTextarea);\n}\n\nfunction calculateNodeHeight(uiTextNode, uid, useCache, minRows, maxRows) {\n  if (useCache === void 0) {\n    useCache = false;\n  }\n\n  if (minRows === void 0) {\n    minRows = null;\n  }\n\n  if (maxRows === void 0) {\n    maxRows = null;\n  }\n\n  if (hiddenTextarea.parentNode === null) {\n    document.body.appendChild(hiddenTextarea);\n  } // Copy all CSS properties that have an impact on the height of the content in\n  // the textbox\n\n\n  var nodeStyling = calculateNodeStyling(uiTextNode, uid, useCache);\n\n  if (nodeStyling === null) {\n    return null;\n  }\n\n  var paddingSize = nodeStyling.paddingSize,\n      borderSize = nodeStyling.borderSize,\n      boxSizing = nodeStyling.boxSizing,\n      sizingStyle = nodeStyling.sizingStyle; // Need to have the overflow attribute to hide the scrollbar otherwise\n  // text-lines will not calculated properly as the shadow will technically be\n  // narrower for content\n\n  Object.keys(sizingStyle).forEach(function (key) {\n    hiddenTextarea.style[key] = sizingStyle[key];\n  });\n  forceHiddenStyles(hiddenTextarea);\n  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || 'x';\n  var minHeight = -Infinity;\n  var maxHeight = Infinity;\n  var height = hiddenTextarea.scrollHeight;\n\n  if (boxSizing === 'border-box') {\n    // border-box: add border, since height = content + padding + border\n    height = height + borderSize;\n  } else if (boxSizing === 'content-box') {\n    // remove padding, since height = content\n    height = height - paddingSize;\n  } // measure height of a textarea with a single row\n\n\n  hiddenTextarea.value = 'x';\n  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize; // Stores the value's rows count rendered in `hiddenTextarea`,\n  // regardless if `maxRows` or `minRows` props are passed\n\n  var valueRowCount = Math.floor(height / singleRowHeight);\n\n  if (minRows !== null) {\n    minHeight = singleRowHeight * minRows;\n\n    if (boxSizing === 'border-box') {\n      minHeight = minHeight + paddingSize + borderSize;\n    }\n\n    height = Math.max(minHeight, height);\n  }\n\n  if (maxRows !== null) {\n    maxHeight = singleRowHeight * maxRows;\n\n    if (boxSizing === 'border-box') {\n      maxHeight = maxHeight + paddingSize + borderSize;\n    }\n\n    height = Math.min(maxHeight, height);\n  }\n\n  var rowCount = Math.floor(height / singleRowHeight);\n  return {\n    height: height,\n    minHeight: minHeight,\n    maxHeight: maxHeight,\n    rowCount: rowCount,\n    valueRowCount: valueRowCount\n  };\n}\n\nfunction calculateNodeStyling(node, uid, useCache) {\n  if (useCache === void 0) {\n    useCache = false;\n  }\n\n  if (useCache && computedStyleCache[uid]) {\n    return computedStyleCache[uid];\n  }\n\n  var style = window.getComputedStyle(node);\n\n  if (style === null) {\n    return null;\n  }\n\n  var sizingStyle = SIZING_STYLE.reduce(function (obj, name) {\n    obj[name] = style.getPropertyValue(name);\n    return obj;\n  }, {});\n  var boxSizing = sizingStyle['box-sizing']; // probably node is detached from DOM, can't read computed dimensions\n\n  if (boxSizing === '') {\n    return null;\n  } // IE (Edge has already correct behaviour) returns content width as computed width\n  // so we need to add manually padding and border widths\n\n\n  if (isIE && boxSizing === 'border-box') {\n    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(style['border-right-width']) + parseFloat(style['border-left-width']) + parseFloat(style['padding-right']) + parseFloat(style['padding-left']) + 'px';\n  }\n\n  var paddingSize = parseFloat(sizingStyle['padding-bottom']) + parseFloat(sizingStyle['padding-top']);\n  var borderSize = parseFloat(sizingStyle['border-bottom-width']) + parseFloat(sizingStyle['border-top-width']);\n  var nodeInfo = {\n    sizingStyle: sizingStyle,\n    paddingSize: paddingSize,\n    borderSize: borderSize,\n    boxSizing: boxSizing\n  };\n\n  if (useCache) {\n    computedStyleCache[uid] = nodeInfo;\n  }\n\n  return nodeInfo;\n}\n\nvar purgeCache = function purgeCache(uid) {\n  delete computedStyleCache[uid];\n};\n\nvar noop = function noop() {};\n\nvar uid = 0;\n\nvar TextareaAutosize =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(TextareaAutosize, _React$Component);\n\n  function TextareaAutosize(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n\n    _this._onRef = function (node) {\n      _this._ref = node;\n      var inputRef = _this.props.inputRef;\n\n      if (typeof inputRef === 'function') {\n        inputRef(node);\n        return;\n      }\n\n      inputRef.current = node;\n    };\n\n    _this._onChange = function (event) {\n      if (!_this._controlled) {\n        _this._resizeComponent();\n      }\n\n      _this.props.onChange(event, _assertThisInitialized(_this));\n    };\n\n    _this._resizeComponent = function (callback) {\n      if (callback === void 0) {\n        callback = noop;\n      }\n\n      var nodeHeight = calculateNodeHeight(_this._ref, _this._uid, _this.props.useCacheForDOMMeasurements, _this.props.minRows, _this.props.maxRows);\n\n      if (nodeHeight === null) {\n        callback();\n        return;\n      }\n\n      var height = nodeHeight.height,\n          minHeight = nodeHeight.minHeight,\n          maxHeight = nodeHeight.maxHeight,\n          rowCount = nodeHeight.rowCount,\n          valueRowCount = nodeHeight.valueRowCount;\n      _this.rowCount = rowCount;\n      _this.valueRowCount = valueRowCount;\n\n      if (_this.state.height !== height || _this.state.minHeight !== minHeight || _this.state.maxHeight !== maxHeight) {\n        _this.setState({\n          height: height,\n          minHeight: minHeight,\n          maxHeight: maxHeight\n        }, callback);\n\n        return;\n      }\n\n      callback();\n    };\n\n    _this.state = {\n      height: props.style && props.style.height || 0,\n      minHeight: -Infinity,\n      maxHeight: Infinity\n    };\n    _this._uid = uid++;\n    _this._controlled = props.value !== undefined;\n    _this._resizeLock = false;\n    return _this;\n  }\n\n  var _proto = TextareaAutosize.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        _inputRef = _this$props.inputRef,\n        _maxRows = _this$props.maxRows,\n        _minRows = _this$props.minRows,\n        _onHeightChange = _this$props.onHeightChange,\n        _useCacheForDOMMeasurements = _this$props.useCacheForDOMMeasurements,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"inputRef\", \"maxRows\", \"minRows\", \"onHeightChange\", \"useCacheForDOMMeasurements\"]);\n\n    props.style = _extends({}, props.style, {\n      height: this.state.height\n    });\n    var maxHeight = Math.max(props.style.maxHeight || Infinity, this.state.maxHeight);\n\n    if (maxHeight < this.state.height) {\n      props.style.overflow = 'hidden';\n    }\n\n    return createElement(\"textarea\", _extends({}, props, {\n      onChange: this._onChange,\n      ref: this._onRef\n    }));\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    this._resizeComponent(); // Working around Firefox bug which runs resize listeners even when other JS is running at the same moment\n    // causing competing rerenders (due to setState in the listener) in React.\n    // More can be found here - facebook/react#6324\n\n\n    this._resizeListener = function () {\n      if (_this2._resizeLock) {\n        return;\n      }\n\n      _this2._resizeLock = true;\n\n      _this2._resizeComponent(function () {\n        _this2._resizeLock = false;\n      });\n    };\n\n    window.addEventListener('resize', this._resizeListener);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (prevProps !== this.props) {\n      this._resizeComponent();\n    }\n\n    if (this.state.height !== prevState.height) {\n      this.props.onHeightChange(this.state.height, this);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    window.removeEventListener('resize', this._resizeListener);\n    purgeCache(this._uid);\n  };\n\n  return TextareaAutosize;\n}(Component);\n\nTextareaAutosize.defaultProps = {\n  inputRef: noop,\n  onChange: noop,\n  onHeightChange: noop,\n  useCacheForDOMMeasurements: false\n};\nprocess.env.NODE_ENV !== \"production\" ? TextareaAutosize.propTypes = {\n  inputRef: oneOfType([func, shape({\n    current: any\n  })]),\n  maxRows: number,\n  minRows: number,\n  onChange: func,\n  onHeightChange: func,\n  style: object,\n  useCacheForDOMMeasurements: bool,\n  value: string\n} : void 0;\n\nexport default TextareaAutosize;\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","/**\n * @flow\n * @file Status Skill Card component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport messages from '../../../common/messages';\nimport {\n    SKILLS_ERROR_EXTERNAL_AUTH,\n    SKILLS_ERROR_BILLING,\n    SKILLS_ERROR_UNKNOWN,\n    SKILLS_ERROR_INVOCATIONS,\n    SKILLS_ERROR_FILE_PROCESSING,\n    SKILLS_ERROR_INVALID_FILE_SIZE,\n    SKILLS_ERROR_INVALID_FILE_FORMAT,\n    SKILLS_STATUS_PENDING,\n    SKILLS_STATUS_INVOKED,\n} from '../../../../constants';\n\ntype Props = {\n    card: SkillCard,\n};\n\nconst Status = ({ card }: Props) => {\n    const { status = {} }: SkillCard = card;\n    const { code, message }: SkillCardLocalizableType = status;\n    let localizedMessage = messages.skillUnknownError;\n\n    switch (code) {\n        case SKILLS_ERROR_INVALID_FILE_SIZE:\n            localizedMessage = messages.skillInvalidFileSizeError;\n            break;\n        case SKILLS_ERROR_INVALID_FILE_FORMAT:\n            localizedMessage = messages.skillInvalidFileExtensionError;\n            break;\n        case SKILLS_ERROR_EXTERNAL_AUTH:\n        case SKILLS_ERROR_BILLING:\n        case SKILLS_ERROR_INVOCATIONS:\n        case SKILLS_ERROR_UNKNOWN:\n            localizedMessage = messages.skillUnknownError;\n            break;\n        case SKILLS_ERROR_FILE_PROCESSING:\n            localizedMessage = messages.skillFileProcessingError;\n            break;\n        case SKILLS_STATUS_PENDING:\n            localizedMessage = messages.skillPendingStatus;\n            break;\n        case SKILLS_STATUS_INVOKED:\n            localizedMessage = messages.skillInvokedStatus;\n            break;\n        default:\n            if (message) {\n                return message;\n            }\n    }\n\n    return <FormattedMessage {...localizedMessage} />;\n};\n\nexport default Status;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconCopy = ({ className = '', color = '#999', height = 14, title, width = 14 }: Props) => (\n    <AccessibleSVG className={`icon-copy ${className}`} height={height} title={title} viewBox=\"0 0 14 14\" width={width}>\n        <path\n            className=\"fill-color\"\n            d=\"M1 11a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h9a1 1 0 0 1 0 2H2v8a1 1 0 0 1-1 1z\"\n            fill={color}\n        />\n        <path\n            className=\"fill-color\"\n            d=\"M13 3H3v10a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1zm-3 8H7a1 1 0 0 1 0-2h3a1 1 0 0 1 0 2zm0-3H7a1 1 0 0 1 0-2h3a1 1 0 0 1 0 2z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconCopy;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconExpand = ({ className = '', color = '#979797', height = 13, title, width = 13 }: Props) => (\n    <AccessibleSVG\n        className={`icon-expand ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 13 13\"\n        width={width}\n    >\n        <path\n            className=\"fill-color\"\n            d=\"M12 0H6a1 1 0 0 0 0 2h5v5a1 1 0 0 0 2 0V1a1 1 0 0 0-1-1zM7 11H2V6a1 1 0 0 0-2 0v6a1 1 0 0 0 1 1h6a1 1 0 0 0 0-2z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconExpand;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconCollapse = ({ className = '', color = '#979797', height = 13, title, width = 13 }: Props) => (\n    <AccessibleSVG\n        className={`icon-collapse ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 13 13\"\n        width={width}\n    >\n        <path\n            className=\"fill-color\"\n            d=\"M8 6h4a1 1 0 0 0 0-2H9V1a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1zM1 9h3v3a1 1 0 0 0 2 0V8a1 1 0 0 0-1-1H1a1 1 0 0 0 0 2z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconCollapse;\n","/**\n * @flow\n * @file Utility for copying and downloading\n * @author Box\n */\n\n/**\n * Function to download string as txt file\n *\n * @private\n * @param {String} string - string to download\n * @param {String} name - file name to use\n * @return {void}\n */\nfunction download(string: string, name: string) {\n    const blob = new Blob([string], { type: 'text/plain;charset=utf-8' });\n\n    // IE11\n    if (window.navigator.msSaveBlob) {\n        window.navigator.msSaveBlob(blob, name);\n        return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n\n    a.style.display = 'none';\n    a.href = url;\n    a.download = name;\n    if (document.body) {\n        document.body.appendChild(a);\n    }\n\n    a.click();\n\n    setTimeout(() => {\n        if (document.body) {\n            document.body.removeChild(a);\n        }\n\n        URL.revokeObjectURL(url);\n    }, 100);\n}\n\n/**\n * Function to copy string to the clipboard\n *\n * @private\n * @param {String} string - string to copy\n * @return {void}\n */\nfunction copy(string: string) {\n    const textarea = document.createElement('textarea');\n    const { body } = document;\n\n    textarea.value = string;\n    textarea.style.display = 'hidden';\n\n    if (body) {\n        body.appendChild(textarea);\n        textarea.select();\n        document.execCommand('copy');\n        body.removeChild(textarea);\n    }\n}\n\nexport { download, copy };\n","/**\n * @flow\n * @file Transcript utils\n * @author Box\n */\n\n/**\n * Returns true if there is a valid start time\n *\n * @param {SkillCardEntryTimeSlice} timeslices - skill entry time slice\n * @return {boolean} if there is a valid start time\n */\nconst isValidStartTime = (timeslice: SkillCardEntryTimeSlice): boolean =>\n    !!timeslice && typeof timeslice.start === 'number';\n\n/**\n * Returns true if there is a valid time slice with valid start time\n *\n * @param {SkillCardEntryTimeSlice[]} timeslices - skill entry time slice\n * @return {boolean} if it is a valid time slice\n */\nconst isValidTimeSlice = (timeslices?: SkillCardEntryTimeSlice[]): boolean =>\n    Array.isArray(timeslices) && isValidStartTime(timeslices[0]);\n\nexport { isValidTimeSlice, isValidStartTime };\n","/**\n * @flow\n * @file Read only transcript row component\n * @author Box\n */\n\nimport * as React from 'react';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\n\ntype Props = {\n    interactionTarget: string,\n    onClick: Function,\n    text?: string,\n    time?: string,\n};\n\nconst ReadOnlyTranscriptRow = ({ time, text = '', onClick, interactionTarget }: Props) => (\n    <PlainButton className=\"be-transcript-row\" data-resin-target={interactionTarget} onClick={onClick} type=\"button\">\n        {time && <div className=\"be-transcript-time\">{time}</div>}\n        <div className=\"be-transcript-text\">{text}</div>\n    </PlainButton>\n);\n\nexport default ReadOnlyTranscriptRow;\n","/**\n * @flow\n * @file Editable transcript row component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport TextareaAutosize from 'react-textarea-autosize';\nimport PrimaryButton from '../../../../components/primary-button/PrimaryButton';\nimport Button from '../../../../components/button/Button';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport './EditingTranscriptRow.scss';\n\ntype Props = {\n    onCancel: Function,\n    onChange: Function,\n    onSave: Function,\n    text?: string,\n    time?: string,\n};\n\nconst EditingTranscriptRow = ({ time, text = '', onSave, onCancel, onChange }: Props) => (\n    <div className=\"be-transcript-row be-transcript-editing-row\">\n        {time && <div className=\"be-transcript-time\">{time}</div>}\n        <div className=\"be-transcript-text\">\n            <TextareaAutosize maxRows={10} onChange={onChange} value={text} />\n            <div className=\"be-transcript-buttons\">\n                <Button data-resin-target={SKILLS_TARGETS.TRANSCRIPTS.EDIT_CANCEL} onClick={onCancel} type=\"button\">\n                    <FormattedMessage {...messages.cancel} />\n                </Button>\n                <PrimaryButton data-resin-target={SKILLS_TARGETS.TRANSCRIPTS.EDIT_SAVE} onClick={onSave} type=\"button\">\n                    <FormattedMessage {...messages.save} />\n                </PrimaryButton>\n            </div>\n        </div>\n    </div>\n);\n\nexport default EditingTranscriptRow;\n","/**\n * @flow\n * @file Transcript row component\n * @author Box\n */\n\nimport React from 'react';\nimport { formatTime } from '../../../../utils/datetime';\nimport ReadOnlyTranscriptRow from './ReadOnlyTranscriptRow';\nimport EditingTranscriptRow from './EditingTranscriptRow';\nimport { isValidTimeSlice } from './timeSliceUtils';\n\nimport './TranscriptRow.scss';\n\ntype Props = {\n    appears?: Array<SkillCardEntryTimeSlice>,\n    interactionTarget: string,\n    isEditing: boolean,\n    onCancel: Function,\n    onChange: Function,\n    onClick: Function,\n    onSave: Function,\n    text?: string,\n};\n\nconst TranscriptRow = ({ appears, text, isEditing, onClick, onSave, onCancel, onChange, interactionTarget }: Props) => {\n    const isValid = isValidTimeSlice(appears) && Array.isArray(appears) && appears.length === 1;\n    const timeSlice = ((appears: any): Array<SkillCardEntryTimeSlice>);\n    const start = isValid ? formatTime(timeSlice[0].start) : undefined;\n\n    return isEditing ? (\n        <EditingTranscriptRow onCancel={onCancel} onChange={onChange} onSave={onSave} text={text} time={start} />\n    ) : (\n        <ReadOnlyTranscriptRow interactionTarget={interactionTarget} onClick={onClick} text={text} time={start} />\n    );\n};\n\nexport default TranscriptRow;\n","/**\n * @flow\n * @file Transcript component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport { bdlGray50 } from '../../../../styles/variables';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconEdit from '../../../../icons/general/IconEdit';\nimport IconCopy from '../../../../icons/general/IconCopy';\nimport IconExpand from '../../../../icons/general/IconExpand';\nimport IconCollapse from '../../../../icons/general/IconCollapse';\nimport { formatTime } from '../../../../utils/datetime';\nimport LoadingIndicatorWrapper from '../../../../components/loading-indicator/LoadingIndicatorWrapper';\nimport Tooltip from '../../../../components/tooltip/Tooltip';\nimport { copy } from '../../../../utils/download';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport messages from '../../../common/messages';\nimport { isValidTimeSlice } from './timeSliceUtils';\nimport TranscriptRow from './TranscriptRow';\nimport './Transcript.scss';\n\ntype Props = {\n    card: SkillCard,\n    getViewer?: Function,\n    isEditable: boolean,\n    onSkillChange: Function,\n};\n\ntype State = {\n    isCollapsed: boolean,\n    isEditingIndex?: number,\n    isLoading: boolean,\n    newTranscriptText: string,\n};\n\nclass Transcript extends React.PureComponent<Props, State> {\n    props: Props;\n\n    state: State = {\n        isEditingIndex: undefined,\n        newTranscriptText: '',\n        isCollapsed: true,\n        isLoading: false,\n    };\n\n    copyBtn: HTMLButtonElement;\n\n    /**\n     * Called when transcripts gets new properties\n     *\n     * @private\n     * @return {void}\n     */\n    componentDidUpdate(prevProps: Props): void {\n        if (prevProps === this.props) {\n            return;\n        }\n\n        const wasEditing = typeof this.state.isEditingIndex === 'number';\n        this.setState({\n            isEditingIndex: wasEditing ? -1 : undefined,\n            newTranscriptText: '',\n            isLoading: false,\n        });\n    }\n\n    /**\n     * Reducer to accumulate all transcript entries for copying\n     *\n     * @param {Object} accumulator - reducer accumulator\n     * @return {string} accumulated transcript entries\n     */\n    transcriptReducer = (accumulator: string, { appears, text }: SkillCardEntry): string => {\n        const start: string =\n            isValidTimeSlice(appears) && Array.isArray(appears) ? `${formatTime(appears[0].start)}:` : '';\n        return `${accumulator}${start} ${text || ''}\\r\\n`;\n    };\n\n    /**\n     * Mapper to accumulate all transcript entries for displaying\n     *\n     * @param {Object} accumulator - reducer accumulator\n     * @param {number} index - mapper index\n     * @return {string} accumulated transcript entries\n     */\n    transcriptMapper = ({ appears, text }: SkillCardEntry, index: number): React.Node => {\n        const { isEditingIndex, newTranscriptText }: State = this.state;\n        const isEditingRow = isEditingIndex === index;\n        const transcriptText = isEditingRow ? newTranscriptText : text;\n        const interactionTarget = isEditingRow\n            ? SKILLS_TARGETS.TRANSCRIPTS.EDIT_TEXT\n            : SKILLS_TARGETS.TRANSCRIPTS.TRANSCRIPT;\n        return (\n            <TranscriptRow\n                key={index}\n                appears={appears}\n                interactionTarget={interactionTarget}\n                isEditing={isEditingRow}\n                onCancel={this.onCancel}\n                onChange={this.onChange}\n                onClick={() => this.onClick(index)}\n                onSave={this.onSave}\n                text={transcriptText}\n            />\n        );\n    };\n\n    /**\n     * Toggles the edit mode\n     *\n     * @private\n     * @return {void}\n     */\n    toggleIsEditing = (): void => {\n        this.setState(prevState => ({\n            isEditingIndex: typeof prevState.isEditingIndex === 'number' ? undefined : -1,\n        }));\n    };\n\n    /**\n     * Previews a transcript segment\n     *\n     * @private\n     * @param {number|void} [index] - row index to edit\n     * @return {void}\n     */\n    previewSegment(index: number) {\n        const {\n            card: { entries },\n            getViewer,\n        }: Props = this.props;\n        const { appears } = entries[index];\n        const viewer = getViewer ? getViewer() : null;\n        const isValid = isValidTimeSlice(appears) && Array.isArray(appears) && appears.length === 1;\n        const timeSlice = ((appears: any): Array<SkillCardEntryTimeSlice>);\n        const start = isValid ? timeSlice[0].start : 0;\n\n        if (isValid && viewer && typeof viewer.play === 'function') {\n            viewer.play(start);\n        }\n    }\n\n    /**\n     * Saves the new card data\n     *\n     * @private\n     * @return {void}\n     */\n    onSave = (): void => {\n        const {\n            card: { entries },\n            onSkillChange,\n        }: Props = this.props;\n        const { isEditingIndex, newTranscriptText }: State = this.state;\n\n        if (typeof isEditingIndex !== 'number') {\n            return;\n        }\n\n        const entry = entries[isEditingIndex];\n        if (entry.text === newTranscriptText) {\n            this.onCancel();\n        } else {\n            this.setState({ isLoading: true, isEditingIndex: -1 });\n            onSkillChange(null, null, [\n                {\n                    replacement: { ...entry, text: newTranscriptText },\n                    replaced: entry,\n                },\n            ]);\n        }\n    };\n\n    /**\n     * Cancels editing\n     *\n     * @private\n     * @return {void}\n     */\n    onCancel = (): void => {\n        this.setState({ isEditingIndex: -1, newTranscriptText: '' });\n    };\n\n    /**\n     * Reflects changes of editing\n     *\n     * @private\n     * @param {Event} event - keyboard event\n     * @return {void}\n     */\n    onChange = (event: SyntheticKeyboardEvent<HTMLTextAreaElement>): void => {\n        const currentTarget = (event.currentTarget: HTMLTextAreaElement);\n        this.setState({\n            newTranscriptText: currentTarget.value,\n        });\n    };\n\n    /**\n     * Click handler for transcript\n     *\n     * @private\n     * @return {void}\n     */\n    onClick = (index: number): void => {\n        const {\n            card: { entries },\n        }: Props = this.props;\n        const { isEditingIndex }: State = this.state;\n        if (typeof isEditingIndex === 'number') {\n            this.setState({\n                isEditingIndex: index,\n                newTranscriptText: entries[index].text,\n            });\n        } else {\n            this.previewSegment(index);\n        }\n    };\n\n    /**\n     * Copies the transcript.\n     * Also animates the copy button.\n     *\n     * @private\n     * @return {void}\n     */\n    copyTranscript = () => {\n        const {\n            card: { entries },\n        }: Props = this.props;\n        const copiedClass = 'be-transcript-copied';\n        copy(entries.reduce(this.transcriptReducer, ''));\n\n        // Animate the button by adding a class\n        if (this.copyBtn) {\n            this.copyBtn.classList.add(copiedClass);\n        }\n\n        // Remove the animation class\n        setTimeout(() => {\n            if (this.copyBtn) {\n                this.copyBtn.classList.remove(copiedClass);\n            }\n        }, 1000);\n    };\n\n    /**\n     * Copy button reference\n     *\n     * @private\n     * @return {void}\n     */\n    copyBtnRef = (btn: HTMLButtonElement): void => {\n        this.copyBtn = btn;\n    };\n\n    /**\n     * Toggles transcript exapand and collapse\n     *\n     * @private\n     * @return {void}\n     */\n    toggleExpandCollapse = (): void => {\n        this.setState(prevState => ({\n            isCollapsed: !prevState.isCollapsed,\n        }));\n    };\n\n    /**\n     * Renders the transcript\n     *\n     * @private\n     * @return {Object}\n     */\n    render() {\n        const {\n            card: { entries },\n            isEditable,\n        }: Props = this.props;\n        const { isEditingIndex, isCollapsed, isLoading }: State = this.state;\n        const hasEntries = entries.length > 0;\n        const hasManyEntries = entries.length > 5;\n        const isEditing = typeof isEditingIndex === 'number';\n        const editBtnClassName = classNames('be-transcript-edit', {\n            'be-transcript-is-editing': isEditing,\n        });\n        const contentClassName = classNames({\n            'be-transcript-content-collapsed': isCollapsed,\n        });\n        const expandCollapseMessage = isCollapsed ? messages.expand : messages.collapse;\n\n        return (\n            <LoadingIndicatorWrapper className=\"be-transcript\" isLoading={isLoading}>\n                {hasEntries && !isLoading && (\n                    <div className=\"be-transcript-actions\">\n                        <Tooltip text={<FormattedMessage {...messages.copy} />}>\n                            <PlainButton\n                                className=\"be-transcript-copy\"\n                                data-resin-target={SKILLS_TARGETS.TRANSCRIPTS.COPY}\n                                getDOMRef={this.copyBtnRef}\n                                onClick={this.copyTranscript}\n                                type=\"button\"\n                            >\n                                <IconCopy color={bdlGray50} />\n                            </PlainButton>\n                        </Tooltip>\n                        {hasManyEntries && (\n                            <Tooltip text={<FormattedMessage {...expandCollapseMessage} />}>\n                                <PlainButton\n                                    className=\"be-transcript-expand\"\n                                    data-resin-target={SKILLS_TARGETS.TRANSCRIPTS.EXPAND}\n                                    onClick={this.toggleExpandCollapse}\n                                    type=\"button\"\n                                >\n                                    {isCollapsed ? (\n                                        <IconExpand color={bdlGray50} />\n                                    ) : (\n                                        <IconCollapse color={bdlGray50} />\n                                    )}\n                                </PlainButton>\n                            </Tooltip>\n                        )}\n                        {isEditable && (\n                            <Tooltip text={<FormattedMessage {...messages.editLabel} />}>\n                                <PlainButton\n                                    className={editBtnClassName}\n                                    data-resin-target={SKILLS_TARGETS.TRANSCRIPTS.EDIT}\n                                    onClick={this.toggleIsEditing}\n                                    type=\"button\"\n                                >\n                                    <IconEdit />\n                                </PlainButton>\n                            </Tooltip>\n                        )}\n                    </div>\n                )}\n                {isEditing ? (\n                    <div className=\"be-transcript-edit-message\">\n                        <FormattedMessage {...messages.transcriptEdit} />\n                    </div>\n                ) : null}\n                {hasEntries ? (\n                    <div className={contentClassName}>{entries.map(this.transcriptMapper)}</div>\n                ) : (\n                    <FormattedMessage {...messages.skillNoInfoFoundError} />\n                )}\n            </LoadingIndicatorWrapper>\n        );\n    }\n}\n\nexport default Transcript;\n","/**\n * @flow\n * @file Utilities for keywords skill\n * @author Box\n */\n\nimport type { Pill } from './flowTypes';\n\n/**\n * Converts skill card entries into pills\n *\n * @private\n * @param {Array<Object>} props - keyword entries\n * @return {Array<Object>} pills\n */\nconst getPills = (keywords: Array<SkillCardEntry> = []): Array<Pill> =>\n    keywords.map((keyword: SkillCardEntry, index: number): Pill => ({\n        displayText: ((keyword.text: any): string),\n        value: index,\n    }));\n\nexport default getPills;\n","/**\n * @flow\n * @file Editable Skill Keywords card component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport PillSelector from '../../../../components/pill-selector-dropdown/PillSelector';\nimport PrimaryButton from '../../../../components/primary-button/PrimaryButton';\nimport Button from '../../../../components/button/Button';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport getPills from './keywordUtils';\nimport type { Pill, Pills } from './flowTypes';\nimport './EditableKeywords.scss';\n\ntype Props = {\n    keywords: Array<SkillCardEntry>,\n    onAdd: Function,\n    onCancel: Function,\n    onDelete: Function,\n    onSave: Function,\n};\n\ntype State = {\n    isInCompositionMode: boolean,\n    keyword: string,\n    pills: Pills,\n};\n\nclass EditableKeywords extends React.PureComponent<Props, State> {\n    props: Props;\n\n    state: State;\n\n    /**\n     * [constructor]\n     *\n     * @public\n     * @return {EditableKeywords}\n     */\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            pills: getPills(props.keywords),\n            keyword: '',\n            isInCompositionMode: false,\n        };\n    }\n\n    /**\n     * Called when keywords gets new properties.\n     * Should reset to original state.\n     *\n     * @private\n     * @param {Object} nextProps - component props\n     * @return {void}\n     */\n    componentDidUpdate({ keywords: prevKeywords }: Props): void {\n        const { keywords } = this.props;\n\n        if (prevKeywords !== keywords) {\n            this.setState({ pills: getPills(keywords), keyword: '' });\n        }\n    }\n\n    /**\n     * Called when keywords gets new properties.\n     * Should reset to original state.\n     *\n     * @private\n     * @param {Object} option - pill\n     * @param {number} index - pill index\n     * @return {void}\n     */\n    onRemove = (option: Pill, index: number): void => { // eslint-disable-line\n        const { onDelete, keywords }: Props = this.props;\n        onDelete(keywords[index]);\n    };\n\n    /**\n     * When pressing enter in the pill input box\n     *\n     * @private\n     * @param {Event} event - keyboard event\n     * @return {void}\n     */\n    onKeyDown = ({ key }: SyntheticKeyboardEvent<HTMLInputElement>): void => {\n        if (key === 'Enter' && !this.state.isInCompositionMode) {\n            this.onBlur();\n        }\n    };\n\n    /**\n     * Called when pill selector is blurred.\n     * Adds a new pill if needed.\n     *\n     * @private\n     * @return {void}\n     */\n    onBlur = () => {\n        const { onAdd }: Props = this.props;\n        const { keyword } = this.state;\n\n        if (keyword) {\n            onAdd({\n                type: 'text',\n                text: keyword,\n            });\n        }\n    };\n\n    /**\n     * Enables composition mode.\n     *\n     * @private\n     * @return {void}\n     */\n    onCompositionStart = () => {\n        this.setState({ isInCompositionMode: true });\n    };\n\n    /**\n     * Disables composition mode.\n     *\n     * @private\n     * @return {void}\n     */\n    onCompositionEnd = () => {\n        this.setState({ isInCompositionMode: false });\n    };\n\n    /**\n     * Called when pill selector gets new input value.\n     *\n     * @private\n     * @return {void}\n     */\n    onInput = (event: SyntheticKeyboardEvent<HTMLInputElement>) => {\n        const currentTarget = (event.currentTarget: HTMLInputElement);\n        this.setState({\n            keyword: currentTarget.value,\n        });\n    };\n\n    /**\n     * Renders the keywords\n     *\n     * @private\n     * @return {void}\n     */\n    render() {\n        const { onSave, onCancel }: Props = this.props;\n        const { pills, keyword }: State = this.state;\n        return (\n            <span className=\"pill-selector-wrapper\">\n                <PillSelector\n                    onBlur={this.onBlur}\n                    onCompositionEnd={this.onCompositionEnd}\n                    onCompositionStart={this.onCompositionStart}\n                    onInput={this.onInput}\n                    onKeyDown={this.onKeyDown}\n                    onPaste={this.onInput}\n                    onRemove={this.onRemove}\n                    selectedOptions={pills}\n                    value={keyword}\n                />\n                <div className=\"be-keywords-buttons\">\n                    <Button data-resin-target={SKILLS_TARGETS.KEYWORDS.EDIT_CANCEL} onClick={onCancel} type=\"button\">\n                        <FormattedMessage {...messages.cancel} />\n                    </Button>\n                    <PrimaryButton data-resin-target={SKILLS_TARGETS.KEYWORDS.EDIT_SAVE} onClick={onSave} type=\"button\">\n                        <FormattedMessage {...messages.save} />\n                    </PrimaryButton>\n                </div>\n            </span>\n        );\n    }\n}\n\nexport default EditableKeywords;\n","// @flow\nimport React from 'react';\nimport classNames from 'classnames';\nimport isEqual from 'lodash/isEqual';\n\nimport Button from '../button';\nimport type { Option } from '../pill-selector-dropdown/flowTypes';\n\ntype Props = {\n    buttonProps?: Object,\n    onSelect?: Function,\n    options: Array<Option>,\n    selectedOptions?: Array<Option>,\n};\n\nconst PillCloud = ({ options, onSelect, selectedOptions = [], buttonProps = {} }: Props) => (\n    <div className=\"pill-cloud-container\">\n        {options &&\n            options.map(option => (\n                <Button\n                    key={option.value}\n                    className={classNames('pill', 'pill-cloud-button', {\n                        'is-selected': selectedOptions.find(op => isEqual(op, option)),\n                    })}\n                    onClick={onSelect ? () => onSelect(option) : undefined}\n                    {...buttonProps}\n                >\n                    {option.displayText}\n                </Button>\n            ))}\n    </div>\n);\n\nexport default PillCloud;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconTrackNext = ({ className = '', color = '#999', height = 14, title, width = 14 }: Props) => (\n    <AccessibleSVG\n        className={`icon-track-next ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 14 14\"\n        width={width}\n    >\n        <path\n            className=\"fill-color\"\n            d=\"M7.72 7.85a1 1 0 0 0 0-1.41l-5-4.81A1 1 0 0 0 2 1.35a1 1 0 0 0-1 1V12a1 1 0 0 0 .28.69 1 1 0 0 0 1.41 0l5-4.81zM13 2v10a1 1 0 0 1-1 1 1 1 0 0 1-1-1V2a1 1 0 0 1 1-1 1 1 0 0 1 1 1z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconTrackNext;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconTrackPrevious = ({ className = '', color = '#999', height = 14, title, width = 14 }: Props) => (\n    <AccessibleSVG\n        className={`icon-track-previous ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 14 14\"\n        width={width}\n    >\n        <path\n            className=\"fill-color\"\n            d=\"M6.31 7.88l5 4.81a1 1 0 0 0 1.41 0A1 1 0 0 0 13 12V2.35a1 1 0 0 0-1-1 1 1 0 0 0-.69.28l-5 4.81a1 1 0 0 0 0 1.41zM2 1a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1 1 1 0 0 1-1-1V2a1 1 0 0 1 1-1z\"\n            fill={color}\n        />\n    </AccessibleSVG>\n);\n\nexport default IconTrackPrevious;\n","/**\n * @flow\n * @file Timeline line component\n * @author Box\n */\n\nimport React from 'react';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport './Timeslice.scss';\n\ntype Props = {\n    duration: number,\n    end?: number,\n    index: number,\n    interactionTarget: string,\n    onClick: Function,\n    start: number,\n};\n\nconst LENGTH_TEXT_ITEMLINE = 290; // match with css\nconst MIN_WIDTH = 6; // Need at least some width to be clickable\n\nconst Timeslice = ({ start, end, duration, onClick, index, interactionTarget }: Props) => {\n    if (typeof start !== 'number' || !duration || start >= duration) {\n        return null;\n    }\n\n    const barLength = LENGTH_TEXT_ITEMLINE;\n    let startLeft = Math.round((start * barLength) / duration);\n    const minEnding = startLeft + MIN_WIDTH; // Need at least some width to be clickable\n    const ending = typeof end === 'number' ? Math.max(minEnding, (end * barLength) / duration) : minEnding;\n    const endLeft = Math.round(Math.min(barLength, ending));\n    let width = endLeft - startLeft;\n\n    // If width is too small re-adjust the left position\n    // to get to at least 6px wide for clickability\n    if (width < MIN_WIDTH) {\n        startLeft -= MIN_WIDTH - width;\n        width = MIN_WIDTH;\n    }\n\n    return (\n        <PlainButton\n            className=\"be-timeline-time\"\n            data-resin-target={interactionTarget}\n            onClick={() => onClick(index)}\n            style={{\n                left: `${startLeft}px`,\n                width: `${width}px`,\n            }}\n            type=\"button\"\n        />\n    );\n};\n\nexport default Timeslice;\n","/**\n * @flow\n * @file Timeline component\n * @author Box\n */\n\nimport React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconTrackNext from '../../../../icons/general/IconTrackNext';\nimport IconTrackPrevious from '../../../../icons/general/IconTrackPrevious';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport Timeslice from './Timeslice';\nimport { isValidStartTime } from '../transcript/timeSliceUtils';\n\nimport './Timeline.scss';\n\ntype Props = {\n    duration?: number,\n    getViewer?: Function,\n    interactionTarget: string,\n    text?: string,\n    timeslices?: SkillCardEntryTimeSlice[],\n    type?: SkillCardEntryType,\n    url?: string,\n};\n\nconst Timeline = ({ text = '', duration = 0, timeslices = [], getViewer, interactionTarget }: Props) => {\n    let timeSliceIndex = -1;\n\n    const playSegment = (index: number, incr: number = 0) => {\n        const newIndex = incr > 0 ? Math.min(timeslices.length - 1, index + incr) : Math.max(0, index + incr);\n        const viewer = getViewer ? getViewer() : null;\n        const timeslice = timeslices[newIndex];\n        const validTime = isValidStartTime(timeslice);\n\n        if (validTime && viewer && typeof viewer.play === 'function') {\n            viewer.play(timeslice.start);\n            timeSliceIndex = newIndex;\n        }\n    };\n\n    return (\n        <div className=\"be-timeline\">\n            {text && <div className=\"be-timeline-label\">{text}</div>}\n            <div className=\"be-timeline-line-wrapper\">\n                <div className=\"be-timeline-line\" />\n                {timeslices.map(\n                    ({ start, end }: SkillCardEntryTimeSlice, index) => (\n                        /* eslint-disable react/no-array-index-key */\n                        <Timeslice\n                            key={index}\n                            duration={duration}\n                            end={end}\n                            index={index}\n                            interactionTarget={interactionTarget}\n                            onClick={playSegment}\n                            start={start}\n                        />\n                    ),\n                    /* eslint-enable react/no-array-index-key */\n                )}\n            </div>\n            <div className=\"be-timeline-btns\">\n                <PlainButton\n                    data-resin-target={SKILLS_TARGETS.TIMELINE.PREVIOUS}\n                    onClick={() => playSegment(timeSliceIndex, -1)}\n                    type=\"button\"\n                >\n                    <IconTrackPrevious title={<FormattedMessage {...messages.previousSegment} />} />\n                </PlainButton>\n                <PlainButton\n                    data-resin-target={SKILLS_TARGETS.TIMELINE.NEXT}\n                    onClick={() => playSegment(timeSliceIndex, 1)}\n                    type=\"button\"\n                >\n                    <IconTrackNext title={<FormattedMessage {...messages.nextSegment} />} />\n                </PlainButton>\n            </div>\n        </div>\n    );\n};\n\nexport default Timeline;\n","/**\n * @flow\n * @file Read Only Keywords Card component\n * @author Box\n */\n\nimport * as React from 'react';\nimport PillCloud from '../../../../components/pill-cloud/PillCloud';\nimport { SKILLS_TARGETS, INTERACTION_TARGET } from '../../../common/interactionTargets';\nimport Timeline from '../timeline';\nimport getPills from './keywordUtils';\nimport type { Pill, Pills } from './flowTypes';\nimport './ReadOnlyKeywords.scss';\n\ntype Props = {\n    duration?: number,\n    getViewer?: Function,\n    keywords: Array<SkillCardEntry>,\n};\n\ntype State = {\n    selectedIndex: number,\n};\n\nclass ReadOnlyselecteds extends React.PureComponent<Props, State> {\n    props: Props;\n\n    state: State = {\n        selectedIndex: -1,\n    };\n\n    /**\n     * Shows the time line by selecting the keyword\n     *\n     * @private\n     * @param {Object} pill - keyword\n     * @return {void}\n     */\n    onSelect = (pill: Pill) => {\n        const { selectedIndex }: State = this.state;\n        const newIndex: number = ((pill.value: any): number);\n        this.setState({\n            selectedIndex: selectedIndex === newIndex ? -1 : newIndex,\n        });\n    };\n\n    /**\n     * Renders the keywords\n     *\n     * @private\n     * @return {void}\n     */\n    render() {\n        const { keywords, getViewer, duration }: Props = this.props;\n        const { selectedIndex }: State = this.state;\n        const options: Pills = getPills(keywords);\n        const selected = keywords[selectedIndex];\n        const pillCloudProps = selected ? { selectedOptions: [options[selectedIndex]] } : {};\n\n        return (\n            <>\n                <PillCloud\n                    onSelect={this.onSelect}\n                    options={options}\n                    {...pillCloudProps}\n                    buttonProps={{\n                        [INTERACTION_TARGET]: SKILLS_TARGETS.KEYWORDS.SELECT,\n                    }}\n                />\n                {!!selected && Array.isArray(selected.appears) && selected.appears.length > 0 && (\n                    <Timeline\n                        duration={duration}\n                        getViewer={getViewer}\n                        interactionTarget={SKILLS_TARGETS.KEYWORDS.TIMELINE}\n                        text={selected.text}\n                        timeslices={selected.appears}\n                    />\n                )}\n            </>\n        );\n    }\n}\n\nexport default ReadOnlyselecteds;\n","/**\n * @flow\n * @file File Keywords SkillCard component\n * @author Box\n */\n\nimport React, { PureComponent } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconEdit from '../../../../icons/general/IconEdit';\nimport LoadingIndicatorWrapper from '../../../../components/loading-indicator/LoadingIndicatorWrapper';\nimport InlineError from '../../../../components/inline-error/InlineError';\nimport Tooltip from '../../../../components/tooltip/Tooltip';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport EditableKeywords from './EditableKeywords';\nimport ReadOnlyKeywords from './ReadOnlyKeywords';\n\nimport './Keywords.scss';\n\ntype Props = {\n    card: SkillCard,\n    getViewer?: Function,\n    hasError: boolean,\n    isEditable: boolean,\n    onSkillChange: Function,\n    transcript?: SkillCard,\n};\n\ntype State = {\n    adds: Array<SkillCardEntry>,\n    hasError: boolean,\n    isEditing: boolean,\n    isLoading: boolean,\n    keywords: Array<SkillCardEntry>,\n    removes: Array<SkillCardEntry>,\n};\n\nclass Keywords extends PureComponent<Props, State> {\n    props: Props;\n\n    state: State;\n\n    /**\n     * [constructor]\n     *\n     * @public\n     * @return {Keywords}\n     */\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            keywords: props.card.entries,\n            adds: [],\n            removes: [],\n            isEditing: props.hasError,\n            hasError: props.hasError,\n            isLoading: false,\n        };\n    }\n\n    /**\n     * Helper to reset the state\n     *\n     * @private\n     * @param {Object} props - component props\n     * @return {void}\n     */\n    resetState(props: Props): void {\n        this.setState({\n            keywords: props.card.entries,\n            adds: [],\n            removes: [],\n            isEditing: false,\n            hasError: false,\n            isLoading: false,\n        });\n    }\n\n    /**\n     * Toggles the edit mode\n     *\n     * @private\n     * @return {void}\n     */\n    toggleIsEditing = (): void => {\n        this.setState(prevState => ({\n            isEditing: !prevState.isEditing,\n        }));\n    };\n\n    /**\n     * Adds a new keyword.\n     * Iterates over the transcript to find locations\n     *\n     * @private\n     * @return {void}\n     */\n    onAdd = (keyword: SkillCardEntry): void => {\n        const { transcript }: Props = this.props;\n        const { adds } = this.state;\n        const locations = [];\n        const regex = new RegExp(`\\\\b${((keyword.text: any): string)}\\\\b`, 'i');\n\n        if (transcript && Array.isArray(transcript.entries)) {\n            transcript.entries.forEach(({ text, appears }: SkillCardEntry): void => {\n                if (text && regex.test(text) && Array.isArray(appears) && appears.length > 0) {\n                    locations.push(appears[0]);\n                }\n            });\n        }\n\n        keyword.appears = locations;\n        adds.push(keyword);\n        this.setState({ adds: adds.slice(0) });\n    };\n\n    /**\n     * Deletes a keyword\n     *\n     * @private\n     * @return {void}\n     */\n    onDelete = (keyword: SkillCardEntry): void => {\n        const { adds, removes } = this.state;\n        const addedIndex = adds.findIndex(added => added === keyword);\n        if (addedIndex > -1) {\n            adds.splice(addedIndex, 1);\n            this.setState({ adds: adds.slice(0) });\n        } else {\n            removes.push(keyword);\n            this.setState({ removes: removes.slice(0) });\n        }\n    };\n\n    /**\n     * Saves the new card data\n     *\n     * @private\n     * @return {void}\n     */\n    onSave = (): void => {\n        const { onSkillChange }: Props = this.props;\n        const { removes, adds }: State = this.state;\n        this.toggleIsEditing();\n        if (removes.length > 0 || adds.length > 0) {\n            this.setState({ isLoading: true });\n            onSkillChange(removes, adds);\n        }\n    };\n\n    /**\n     * Cancels editing\n     *\n     * @private\n     * @return {void}\n     */\n    onCancel = (): void => {\n        this.resetState(this.props);\n    };\n\n    /**\n     * Renders the keywords\n     *\n     * @private\n     * @return {void}\n     */\n    render() {\n        const { card, getViewer, isEditable }: Props = this.props;\n        const { duration }: SkillCard = card;\n        const { isEditing, isLoading, hasError, keywords, removes, adds }: State = this.state;\n        const hasKeywords = keywords.length > 0;\n        const entries = keywords.filter((face: SkillCardEntry) => !removes.includes(face)).concat(adds);\n        const editClassName = classNames('be-keyword-edit', {\n            'be-keyword-is-editing': isEditing,\n        });\n\n        return (\n            <LoadingIndicatorWrapper className=\"be-keywords\" isLoading={isLoading}>\n                {hasKeywords && isEditable && !isLoading && (\n                    <Tooltip text={<FormattedMessage {...messages.editLabel} />}>\n                        <PlainButton\n                            className={editClassName}\n                            data-resin-target={SKILLS_TARGETS.KEYWORDS.EDIT}\n                            onClick={this.toggleIsEditing}\n                            type=\"button\"\n                        >\n                            <IconEdit />\n                        </PlainButton>\n                    </Tooltip>\n                )}\n                {hasError && (\n                    <InlineError title={<FormattedMessage {...messages.sidebarSkillsErrorTitle} />}>\n                        <FormattedMessage {...messages.sidebarSkillsErrorContent} />\n                    </InlineError>\n                )}\n                {isEditing && (\n                    <EditableKeywords\n                        keywords={entries}\n                        onAdd={this.onAdd}\n                        onCancel={this.onCancel}\n                        onDelete={this.onDelete}\n                        onSave={this.onSave}\n                    />\n                )}\n                {!isEditing && hasKeywords && (\n                    <ReadOnlyKeywords duration={duration} getViewer={getViewer} keywords={entries} />\n                )}\n                {!isEditing && !hasKeywords && <FormattedMessage {...messages.skillNoInfoFoundError} />}\n            </LoadingIndicatorWrapper>\n        );\n    }\n}\n\nexport default Keywords;\n","// @flow\nimport * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\ntype Props = {\n    className?: string,\n    color?: string,\n    height?: number,\n    /** A text-only string describing the icon if it's not purely decorative for accessibility */\n    title?: string | React.Element<any>,\n    width?: number,\n};\n\nconst IconMinus = ({ className = '', color = '#000000', height = 16, title, width = 16 }: Props) => (\n    <AccessibleSVG\n        className={`icon-minus ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 16 16\"\n        width={width}\n    >\n        <path d=\"M2 5h8v2H2z\" fill={color} fillRule=\"evenodd\" />\n    </AccessibleSVG>\n);\n\nexport default IconMinus;\n","/**\n * @flow\n * @file File Keywords SkillCard component\n * @author Box\n */\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconClose from '../../../../icons/general/IconClose';\nimport IconMinus from '../../../../icons/general/IconMinus';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport { COLOR_999, COLOR_WHITE } from '../../../../constants';\n\nimport './Face.scss';\n\ntype Props = {\n    face: SkillCardEntry,\n    isEditing: boolean,\n    onDelete: Function,\n    onSelect: Function,\n    selected?: SkillCardEntry,\n};\n\nconst Face = ({ face, selected, isEditing, onDelete, onSelect }: Props) => {\n    const isAnyFaceSelected = !!selected;\n    const isCurrentFaceSelected = face === selected;\n    const isFaceSelected = isAnyFaceSelected && isCurrentFaceSelected && !isEditing;\n    const faceClassName = classNames('be-face-wrapper', {\n        'be-face-unselected': !isEditing && isAnyFaceSelected && !isCurrentFaceSelected,\n    });\n\n    return (\n        <div className={faceClassName}>\n            <PlainButton\n                className=\"be-face\"\n                data-resin-target={SKILLS_TARGETS.FACES.FACE}\n                onClick={() => !isEditing && onSelect(face)}\n                type=\"button\"\n            >\n                <img alt={face.text} src={face.image_url} title={face.text} />\n                {isFaceSelected && <IconMinus color={COLOR_WHITE} />}\n            </PlainButton>\n            {isEditing && (\n                <PlainButton\n                    className=\"be-face-delete\"\n                    data-resin-target={SKILLS_TARGETS.FACES.DELETE}\n                    onClick={() => onDelete(face)}\n                    type=\"button\"\n                >\n                    <IconClose color={COLOR_999} height={16} width={16} />\n                </PlainButton>\n            )}\n        </div>\n    );\n};\n\nexport default Face;\n","/**\n * @flow\n * @file Faces Skill Card component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport PrimaryButton from '../../../../components/primary-button/PrimaryButton';\nimport LoadingIndicatorWrapper from '../../../../components/loading-indicator/LoadingIndicatorWrapper';\nimport InlineError from '../../../../components/inline-error/InlineError';\nimport Tooltip from '../../../../components/tooltip/Tooltip';\nimport Button from '../../../../components/button/Button';\nimport IconEdit from '../../../../icons/general/IconEdit';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport Face from './Face';\nimport Timeline from '../timeline';\nimport './Faces.scss';\n\ntype Props = {\n    card: SkillCard,\n    getViewer?: Function,\n    hasError: boolean,\n    isEditable: boolean,\n    onSkillChange: Function,\n};\n\ntype State = {\n    faces: Array<SkillCardEntry>,\n    hasError: boolean,\n    isEditing: boolean,\n    isLoading: boolean,\n    removes: Array<SkillCardEntry>,\n    selected?: SkillCardEntry,\n};\n\nclass Faces extends React.PureComponent<Props, State> {\n    props: Props;\n\n    state: State;\n\n    /**\n     * [constructor]\n     *\n     * @public\n     * @return {Faces}\n     */\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            faces: props.card.entries,\n            removes: [],\n            isEditing: props.hasError,\n            hasError: props.hasError,\n            isLoading: false,\n        };\n    }\n\n    /**\n     * Helper to reset the state\n     *\n     * @private\n     * @param {Object} props - component props\n     * @return {void}\n     */\n    resetState(props: Props): void {\n        this.setState({\n            faces: props.card.entries,\n            removes: [],\n            isEditing: false,\n            selected: undefined,\n            hasError: false,\n            isLoading: false,\n        });\n    }\n\n    /**\n     * Toggles the edit mode\n     *\n     * @private\n     * @return {void}\n     */\n    toggleIsEditing = (): void => {\n        this.setState(prevState => ({\n            isEditing: !prevState.isEditing,\n        }));\n    };\n\n    /**\n     * Toggles face selection\n     *\n     * @private\n     * @return {void}\n     */\n    onSelect = (face: SkillCardEntry): void => {\n        const { selected } = this.state;\n        this.setState({\n            selected: selected === face ? undefined : face,\n        });\n    };\n\n    /**\n     * Deletes a face\n     *\n     * @private\n     * @return {void}\n     */\n    onDelete = (face: SkillCardEntry): void => {\n        const { removes } = this.state;\n        removes.push(face);\n        this.setState({ removes: removes.slice(0) });\n    };\n\n    /**\n     * Saves the new card data\n     *\n     * @private\n     * @return {void}\n     */\n    onSave = (): void => {\n        const { onSkillChange }: Props = this.props;\n        const { removes }: State = this.state;\n        this.toggleIsEditing();\n        if (removes.length > 0) {\n            this.setState({ isLoading: true });\n            onSkillChange(removes);\n        }\n    };\n\n    /**\n     * Cancels editing\n     *\n     * @private\n     * @return {void}\n     */\n    onCancel = (): void => {\n        this.resetState(this.props);\n    };\n\n    /**\n     * Renders the faces\n     *\n     * @private\n     * @return {void}\n     */\n    render() {\n        const { card, isEditable, getViewer }: Props = this.props;\n        const { selected, faces, removes, isEditing, hasError, isLoading }: State = this.state;\n        const { duration }: SkillCard = card;\n        const hasFaces = faces.length > 0;\n        const entries = faces.filter((face: SkillCardEntry) => !removes.includes(face));\n        const editClassName = classNames('be-face-edit', {\n            'be-faces-is-editing': isEditing,\n        });\n\n        return (\n            <LoadingIndicatorWrapper className=\"be-faces\" isLoading={isLoading}>\n                {hasFaces && isEditable && !isLoading && (\n                    <Tooltip text={<FormattedMessage {...messages.editLabel} />}>\n                        <PlainButton\n                            className={editClassName}\n                            data-resin-target={SKILLS_TARGETS.FACES.EDIT}\n                            onClick={this.toggleIsEditing}\n                            type=\"button\"\n                        >\n                            <IconEdit />\n                        </PlainButton>\n                    </Tooltip>\n                )}\n                {hasError && (\n                    <InlineError title={<FormattedMessage {...messages.sidebarSkillsErrorTitle} />}>\n                        <FormattedMessage {...messages.sidebarSkillsErrorContent} />\n                    </InlineError>\n                )}\n                {hasFaces ? (\n                    entries.map((face: SkillCardEntry, index: number) => (\n                        /* eslint-disable react/no-array-index-key */\n                        <Face\n                            key={index}\n                            face={face}\n                            isEditing={isEditing}\n                            onDelete={this.onDelete}\n                            onSelect={this.onSelect}\n                            selected={selected}\n                        />\n                        /* eslint-enable react/no-array-index-key */\n                    ))\n                ) : (\n                    <FormattedMessage {...messages.skillNoInfoFoundError} />\n                )}\n                {!!selected && !isEditing && Array.isArray(selected.appears) && selected.appears.length > 0 && (\n                    <Timeline\n                        duration={duration}\n                        getViewer={getViewer}\n                        interactionTarget={SKILLS_TARGETS.FACES.TIMELINE}\n                        timeslices={selected.appears}\n                    />\n                )}\n                {isEditing && (\n                    <div className=\"be-faces-buttons\">\n                        <Button\n                            data-resin-target={SKILLS_TARGETS.FACES.EDIT_CANCEL}\n                            onClick={this.onCancel}\n                            type=\"button\"\n                        >\n                            <FormattedMessage {...messages.cancel} />\n                        </Button>\n                        <PrimaryButton\n                            data-resin-target={SKILLS_TARGETS.FACES.EDIT_SAVE}\n                            onClick={this.onSave}\n                            type=\"button\"\n                        >\n                            <FormattedMessage {...messages.save} />\n                        </PrimaryButton>\n                    </div>\n                )}\n            </LoadingIndicatorWrapper>\n        );\n    }\n}\n\nexport default Faces;\n","/**\n * @flow\n * @file Skills card component\n * @author Box\n */\n\nimport React from 'react';\nimport Status from './status';\nimport Transcript from './transcript';\nimport Keywords from './keywords';\nimport Faces from './faces';\nimport { SKILLS_TRANSCRIPT, SKILLS_KEYWORD, SKILLS_TIMELINE, SKILLS_FACE, SKILLS_STATUS } from '../../../constants';\n\ntype Props = {\n    card: SkillCard,\n    cards: Array<SkillCard>,\n    getViewer: Function,\n    hasError: boolean,\n    isEditable: boolean,\n    onSkillChange: Function,\n};\n\nconst SidebarSkillsCard = ({ card, cards, hasError, isEditable, onSkillChange, getViewer }: Props) => {\n    switch (card.skill_card_type) {\n        case SKILLS_KEYWORD:\n            return (\n                <Keywords\n                    card={card}\n                    getViewer={getViewer}\n                    hasError={hasError}\n                    isEditable={isEditable}\n                    onSkillChange={onSkillChange}\n                    transcript={\n                        isEditable\n                            ? cards.find(({ skill_card_type }) => skill_card_type === SKILLS_TRANSCRIPT)\n                            : undefined\n                    }\n                />\n            );\n        case SKILLS_TIMELINE:\n        case SKILLS_FACE:\n            return (\n                <Faces\n                    card={card}\n                    getViewer={getViewer}\n                    hasError={hasError}\n                    isEditable={isEditable}\n                    onSkillChange={onSkillChange}\n                />\n            );\n        case SKILLS_TRANSCRIPT:\n            return (\n                <Transcript\n                    card={card}\n                    getViewer={getViewer}\n                    hasError={hasError}\n                    isEditable={isEditable}\n                    onSkillChange={onSkillChange}\n                />\n            );\n        case SKILLS_STATUS:\n            return <Status card={card} />;\n        default:\n            return null;\n    }\n};\n\nexport default SidebarSkillsCard;\n","/**\n * @flow\n * @file Details sidebar component\n * @author Box\n */\n\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport uniqueId from 'lodash/uniqueId';\nimport messages from '../../common/messages';\nimport { SKILLS_TARGETS } from '../../common/interactionTargets';\nimport SidebarSection from '../SidebarSection';\nimport { isValidSkillsCard } from './skillUtils';\nimport SidebarSkillsCard from './SidebarSkillsCard';\nimport {\n    SKILLS_TRANSCRIPT,\n    SKILLS_KEYWORD,\n    SKILLS_TIMELINE,\n    SKILLS_FACE,\n    SKILLS_STATUS,\n    SKILLS_ERROR_UNKNOWN,\n} from '../../../constants';\n\ntype Props = {\n    cards: Array<SkillCard>,\n    errors: NumberBooleanMap,\n    file: BoxItem,\n    getViewer: Function,\n    onSkillChange: Function,\n};\n\n/**\n * Get ths skill interaction target based on card type\n *\n * @param {Object} card - skill card\n * @return {string} - interaction target\n */\nconst getCardInteractionTarget = ({ skill_card_type }: SkillCard): string => {\n    switch (skill_card_type) {\n        case SKILLS_KEYWORD:\n            return SKILLS_TARGETS.KEYWORDS.CARD;\n        case SKILLS_FACE:\n        case SKILLS_TIMELINE:\n            return SKILLS_TARGETS.FACES.CARD;\n        case SKILLS_TRANSCRIPT:\n            return SKILLS_TARGETS.TRANSCRIPTS.CARD;\n        default:\n            return '';\n    }\n};\n\n/**\n * Get ths string skill title based on card title\n *\n * @param {Object} card - skill card\n * @return {string} - skill title\n */\nconst getCardTitle = ({ skill_card_type, skill_card_title = {} }: SkillCard): string | React.Node => {\n    const { code, message }: SkillCardLocalizableType = skill_card_title;\n    const defaultKey = `${skill_card_type}Skill`;\n    const defaultMessage = messages[defaultKey] || messages.defaultSkill;\n\n    switch (code) {\n        case 'skills_faces':\n            return <FormattedMessage {...messages.faceSkill} />;\n        case 'skills_transcript':\n            return <FormattedMessage {...messages.transcriptSkill} />;\n        case 'skills_topics':\n            return <FormattedMessage {...messages.topicsSkill} />;\n        case 'skills_status':\n            return <FormattedMessage {...messages.statusSkill} />;\n        case 'skills_error':\n            return <FormattedMessage {...messages.error} />;\n        default:\n            return message || <FormattedMessage {...defaultMessage} />;\n    }\n};\n\nconst SidebarSkills = ({ file, cards, errors, getViewer, onSkillChange }: Props): Array<React.Node> => {\n    const { permissions = {} }: BoxItem = file;\n    const isSkillEditable = !!permissions.can_upload;\n\n    return cards.map((card: SkillCard, index: number) => {\n        if (card.error && !card.status) {\n            card.skill_card_type = SKILLS_STATUS;\n            card.status = {\n                code: SKILLS_ERROR_UNKNOWN,\n            };\n            delete card.error;\n        }\n\n        const { id } = card;\n        const cardId = id || uniqueId('card_');\n        const isValid = isValidSkillsCard(file, card);\n        const interactionTarget = getCardInteractionTarget(card);\n        const title = getCardTitle(card);\n        const hasEntries = Array.isArray(card.entries) ? card.entries.length > 0 : isValid;\n\n        return isValid ? (\n            <SidebarSection key={cardId} interactionTarget={interactionTarget} isOpen={hasEntries} title={title}>\n                <SidebarSkillsCard\n                    card={card}\n                    cards={cards}\n                    getViewer={getViewer}\n                    hasError={!!errors[index]}\n                    isEditable={isSkillEditable}\n                    onSkillChange={(...args) => onSkillChange(index, ...args)}\n                />\n            </SidebarSection>\n        ) : null;\n    });\n};\n\nexport default SidebarSkills;\n","/**\n * @flow\n * @file Skills sidebar component\n * @author Box\n */\n\nimport * as React from 'react';\nimport flow from 'lodash/flow';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { FormattedMessage } from 'react-intl';\nimport API from '../../api';\nimport LoadingIndicator from '../../components/loading-indicator/LoadingIndicator';\nimport messages from '../common/messages';\nimport SidebarContent from './SidebarContent';\nimport SidebarSkills from './skills/SidebarSkills';\nimport { EVENT_JS_READY } from '../common/logger/constants';\nimport { mark } from '../../utils/performance';\nimport { withAPIContext } from '../common/api-context';\nimport { withErrorBoundary } from '../common/error-boundary';\nimport { withLogger } from '../common/logger';\nimport {\n    FIELD_PERMISSIONS_CAN_UPLOAD,\n    SKILLS_TRANSCRIPT,\n    ORIGIN_SKILLS_SIDEBAR,\n    SIDEBAR_VIEW_SKILLS,\n} from '../../constants';\nimport './SkillsSidebar.scss';\n\ntype PropsWithoutContext = {\n    elementId: string,\n    file: BoxItem,\n    getPreview: Function,\n    getViewer: Function,\n    refreshIdentity?: boolean,\n};\n\ntype Props = {\n    api: API,\n} & PropsWithoutContext &\n    WithLoggerProps;\n\ntype State = {\n    cards?: Array<SkillCard>,\n    errors: NumberBooleanMap,\n};\n\nconst MARK_NAME_JS_READY = `${ORIGIN_SKILLS_SIDEBAR}_${EVENT_JS_READY}`;\n\nmark(MARK_NAME_JS_READY);\n\nclass SkillsSidebar extends React.PureComponent<Props, State> {\n    state: State = {\n        errors: {},\n    };\n\n    constructor(props: Props) {\n        super(props);\n        const { logger } = this.props;\n        logger.onReadyMetric({\n            endMarkName: MARK_NAME_JS_READY,\n        });\n    }\n\n    componentDidMount() {\n        const { api, file }: Props = this.props;\n        api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n    }\n\n    componentDidUpdate({ refreshIdentity: prevRefreshIdentity }: Props) {\n        const { api, file, refreshIdentity }: Props = this.props;\n\n        if (refreshIdentity !== prevRefreshIdentity) {\n            api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n        }\n    }\n\n    /**\n     * Handles skills fetch success\n     *\n     * @private\n     * @param {Array<SkillCard>} cards - Skills cards\n     * @return {void}\n     */\n    fetchSkillsSuccessCallback = (cards: Array<SkillCard>) => {\n        this.updatePreviewTranscript(cards);\n        this.setState({ cards });\n    };\n\n    /**\n     * Updates Preview with transcript data\n     *\n     * @private\n     * @param {Array<SkillCard>} cards - Skills cards\n     * @return {void}\n     */\n    updatePreviewTranscript = (cards: Array<SkillCard>): void => {\n        const { getPreview, getViewer } = this.props;\n        const preview = getPreview ? getPreview() : null;\n        const viewer = getViewer ? getViewer() : null;\n        const transcriptCard = cards.find(card => card.skill_card_type === SKILLS_TRANSCRIPT);\n        if (!transcriptCard || !preview) {\n            return;\n        }\n\n        if (!viewer) {\n            preview.addListener('load', ({ viewer: loadedViewer }) => {\n                if (typeof loadedViewer.loadAutoGeneratedCaptions === 'function') {\n                    loadedViewer.loadAutoGeneratedCaptions(transcriptCard);\n                }\n            });\n        } else if (typeof viewer.loadAutoGeneratedCaptions === 'function') {\n            viewer.loadAutoGeneratedCaptions(transcriptCard);\n        }\n    };\n\n    /**\n     * Success handler for save\n     *\n     * @private\n     * @param {Array} updatedCards - updated skill cards\n     * @param {number} index - index of the card being edited\n     * @return {void}\n     */\n    onSaveSuccessHandler = (index: number, updatedCards: Array<SkillCard>): void => {\n        const { errors }: State = this.state;\n        const clone = { ...errors };\n        delete clone[index];\n        this.updatePreviewTranscript(updatedCards);\n        this.setState({ cards: updatedCards, errors: clone });\n    };\n\n    /**\n     * Error handler for save\n     *\n     * @private\n     * @param {number} index - index of the card being edited\n     * @return {void}\n     */\n    onSaveErrorHandler = (index: number): void => {\n        const { errors }: State = this.state;\n        const clone = { ...errors };\n        clone[index] = true;\n        this.setState({ errors: clone });\n    };\n\n    /**\n     * Updates skill metadata\n     *\n     * @private\n     * @param {number} index - index of the card being edited\n     * @param {Array} removes - entries to remove\n     * @param {Array} adds - entries to add\n     * @param {Array} replaces - entries to replace\n     * @return {void}\n     */\n    onSave = (\n        index: number,\n        removes: Array<SkillCardEntry> = [],\n        adds: Array<SkillCardEntry> = [],\n        replaces: Array<{\n            replaced: SkillCardEntry,\n            replacement: SkillCardEntry,\n        }> = [],\n    ): void => {\n        const { api, file }: Props = this.props;\n        const { cards = [] }: State = this.state;\n        const card = cards[index];\n        const path = `/cards/${index}`;\n        const ops: JSONPatchOperations = [];\n        const canEdit = getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n\n        if (!canEdit || !card) {\n            return;\n        }\n\n        if (Array.isArray(replaces)) {\n            replaces.forEach(({ replaced, replacement }) => {\n                const idx = card.entries.findIndex(entry => entry === replaced);\n                if (idx > -1) {\n                    ops.push({\n                        op: 'replace',\n                        path: `${path}/entries/${idx}`,\n                        value: replacement,\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(removes)) {\n            const deletes = [];\n            removes.forEach(removed => {\n                const idx = card.entries.findIndex(entry => entry === removed);\n                if (idx > -1) {\n                    deletes.push(idx);\n                }\n            });\n            // To maintain metadata index positions, removes should be\n            // done is reverse order with largest index being removed first.\n            // Remove operations are atomic and don't happen in batch.\n            deletes\n                .sort((a, b) => b - a) // number sort in descending order\n                .forEach(idx => {\n                    ops.push({\n                        op: 'remove',\n                        path: `${path}/entries/${idx}`,\n                    });\n                });\n        }\n\n        if (Array.isArray(adds)) {\n            adds.forEach(added => {\n                ops.push({\n                    op: 'add',\n                    path: `${path}/entries/-`,\n                    value: added,\n                });\n            });\n        }\n\n        // If no ops, don't proceed\n        if (ops.length === 0) {\n            return;\n        }\n\n        // Add test ops before any other ops\n        ops.splice(0, 0, {\n            op: 'test',\n            path,\n            value: card,\n        });\n\n        api.getMetadataAPI(false).updateSkills(\n            file,\n            ops,\n            (updatedCards: Array<SkillCard>) => {\n                this.onSaveSuccessHandler(index, updatedCards);\n            },\n            () => {\n                this.onSaveErrorHandler(index);\n            },\n        );\n    };\n\n    render() {\n        const { file, getViewer, elementId }: Props = this.props;\n        const { cards, errors }: State = this.state;\n\n        return (\n            <SidebarContent\n                className=\"bcs-skills\"\n                elementId={elementId}\n                sidebarView={SIDEBAR_VIEW_SKILLS}\n                title={<FormattedMessage {...messages.sidebarSkillsTitle} />}\n            >\n                {cards ? (\n                    <SidebarSkills\n                        cards={cards}\n                        errors={errors}\n                        file={file}\n                        getViewer={getViewer}\n                        onSkillChange={this.onSave}\n                    />\n                ) : (\n                    <LoadingIndicator />\n                )}\n            </SidebarContent>\n        );\n    }\n}\n\nexport { SkillsSidebar as SkillsSidebarComponent };\nexport default flow([withLogger(ORIGIN_SKILLS_SIDEBAR), withErrorBoundary(ORIGIN_SKILLS_SIDEBAR), withAPIContext])(\n    SkillsSidebar,\n);\n"],"sourceRoot":""}